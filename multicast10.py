# -*- coding: utf-8 -*-
"""Multicast10.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1M4fkzJ7r9YmITG0FX8uvjvkmdhsh7DGj
"""

import numpy as np

entries =[
           [0, 3, 1, 4],
           [0, 2, 1, 1],
           [1, 4, 1, 3],
           [1, 3, 2, 4], 
           [2, 4, 3, 5],
           [2, 2, 2, 3]
]

def energy(envoie):
  """Maximum d'energy d'un ensemble de requetes"""
  return np.max(envoie[:,3])

def delais(envoie):
  def exceed_by(u, t_envoie):
    # print("u",u,"t",t_envoie)
    ex = t_envoie - u[1]
    #print(f"ex {ex}")
    return ex if ex > 0 else 0
  # TransmisTransmission ne peut avoir que que si tous les
  #  requêtes sont arrivées 
  t_envoie = np.max(envoie[:,0])
  acc =0;
  for r in envoie:
    acc = acc + exceed_by(r, t_envoie)
  # print ("acc", acc)
  return acc

def partition(collection):
  """ Source : https://stackoverflow.com/a/30134039 """
  if len(collection) == 1:
    yield [ collection ]
    return

  first = collection[0]
  for smaller in partition(collection[1:]):
      # insert `first` in each of the subpartition's subsets
      for n, subset in enumerate(smaller):
          yield smaller[:n] + [[ first ] + subset]  + smaller[n+1:]
      # put `first` in its own subset 
      yield [ [ first ] ] + smaller

def is_partition_ok(p):
  """Verifier si un envoie reponds qu'a un seul contenu"""
  
  chck = []
  for envoie in p:
    un = np.array(envoie)
    # Un seul contenu par envoie
    chck += [len(np.unique(un[:,2]))==1]
  
  # Tous les envoies doivent etre cool
  return all(chck)

def ok_partition(entries):
  for p in partition(entries):
    if is_partition_ok(p):
      yield p
  return



# energy(entries)

# len(np.unique([1, 1, 1, 0]))

for p in partition(entries[:2]):
  is_partition_ok(p)

def naive(entries):
  energie = []
  delay = []
  h=0
  for p in ok_partition(entries):
    # print(h)
    h+=1
    e =[]

    d= []
    for envoie in p:
      e += [energy(np.array(envoie))]
      d += [delais(np.array(envoie))]
    energie += [sum(e)]
    delay += [sum(d)]
    # print(sum(e), sum(d))
  i = np.argmin(energie)

  return energie[i], delay[i]
  # print(energie)
  # print(delay)

def glouton(entries):
  tries = np.array(entries)
  e = []
  d = []
  while(len(tries)):
    
    max_ei = np.argmax(tries[:,0])
    first = tries[max_ei]
    g = np.array([first])
    # print(first, g)
    # print(max_ei, tries)
    tries = np.delete(tries, max_ei, axis=0)
    for r in tries:
      # print(r)
      if r[2] == g[0][2]:
        if is_group_ok(np.append(g, [r], axis=0)):
          g = np.append(g, [r], axis=0)
    e += [energy(np.array(g))]
    d += [delais(np.array(g))]
  return sum(e), sum(d)

def is_group_ok(g):
  # print(g)
  return  np.min(g[:,1]) > np.max(g[:,0])

glouton(entries)

naive(entries)

def genReqs(l=2, de=5, m=4, T=20, seedv=1):
  from random import choices, randint, uniform, seed
  seed(seedv)
  np.random.seed(seedv)

  reqs = []

  for t, s in enumerate(np.random.poisson(l, T)):
    for i in range (s):

      a =  t 
      d = a + randint(1, de )
      reqs += [[
              a,
              d,
              choices(range(1,  m+1))[0],
              1/uniform(1.0, 2.0000001)
              ]]
  return reqs

GL =[]
NV = []
for l in np.arange(0.25, 5.001, 0.20):
  en = genReqs(l=l, seedv=10)
  print(l)
  # if l < 1:
    # nv = naive(en[:])
    # NV += [[l, nv[0]]]
    # print(l, nv[0])
  gl = glouton(en)
  GL += [[l, gl[0]]]
  print(l, gl[0])
  # 0.25 1.5364065631468513

from matplotlib import pyplot as plt
plt.plot(np.array(GL)[:,0][:6], np.array(GL)[:,1][:6])
plt.plot(np.array(NV)[:,0], np.array(NV)[:,1])
plt.legend(["Glouton", "Optimal"])

en = genReqs(l=0.8, seedv=10)
naive(en)

NV = [ 
    [0.25, 1.53],
    [0.40, 2.46],
]

GL

(a,d,m,e)

for l in np.arange(0.25, 5.001, 0.25):
  en = genReqs(l=l, seedv=10)
  if l < 1.25:
    print(l)
    nv =naive(en[:])
    NV += [[l, nv[0]]]
    print(nv)
  gl = glouton(en)

